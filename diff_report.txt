<<report summary>> 
[main 85821f1] updated
 17 files changed, 876 insertions(+), 30 deletions(-)
 create mode 100644 compare_repo/cowtest.c
 create mode 100644 compare_repo/custom.c
 create mode 100644 compare_repo/memtest.c
 create mode 100644 compare_repo/testall.c
##################################################################################
<<main report starts here>>
diff --git a/compare_repo/cowtest.c b/compare_repo/cowtest.c
index fb2e33a..104c487 100644
--- a/compare_repo/cowtest.c
+++ b/compare_repo/cowtest.c
@@ -2,508 +2,66 @@
 #include "stat.h"
 #include "user.h"
 
-void
-test_simple_cow()
+int
+main(int argc, char *argv[])
 {
-  printf(1, "  TEST 1: Simple COW Behavior\n");
-    printf(1, "\n============================\n");
-  
-  int pid = fork();
-  
-  if(pid < 0) {
-    printf(1, "ERROR: fork failed\n");
-    exit();
-  }
-  
-  if(pid == 0) {
-    printf(1, "[CHILD] Immediately after fork:\n");
-    memstats();
-    
-    printf(1, "\n[CHILD] Allocating and writing to trigger COW...\n");
-    char *ptr = malloc(100);
-    if(ptr) {
-      ptr[0] = 'X';
-      free(ptr);
-    }
-    
-    printf(1, "\n[CHILD] After write:\n");
-    memstats();
-    
-    exit();
-  } else {
-    wait();
-    printf(1, "\n[PARENT] After child completes:\n");
-    memstats();
-  }
-}
+  printf(1, "\n=== CMDT Test Program (Task 2 - Copy-On-Write) ===\n\n");
 
-void
-test_multiple_pages()
-{
-  printf(1, "  TEST 2: Multiple Page Writes\n");
-  printf(1, "==================================\n\n");
-  
-  char *buffer = malloc(8192);
-  if(buffer == 0) {
-    printf(1, "ERROR: malloc failed\n");
-    exit();
-  }
-  
-  int i;
-  for(i = 0; i < 8192; i++)
-    buffer[i] = 'A';
-  
-  int pid = fork();
-  
-  if(pid < 0) {
-    printf(1, "ERROR: fork failed\n");
-    free(buffer);
-    exit();
-  }
-  
-  if(pid == 0) {
-    printf(1, "[CHILD] Initial state:\n");
-    memstats();
-    
-    printf(1, "\n[CHILD] Writing to first page...\n");
-    buffer[0] = 'X';
-    
-    printf(1, "\n[CHILD] After page 1 write:\n");
-    memstats();
-    
-    printf(1, "\n[CHILD] Writing to second page...\n");
-    buffer[4096] = 'Y';
-    
-    printf(1, "\n[CHILD] After page 2 write:\n");
-    memstats();
-    
-    free(buffer);
-    exit();
-  } else {
-    wait();
-    free(buffer);
-  }
-}
+  printf(1, "Step 1: Parent before fork\n");
+  printf(1, "----------------------------\n");
+  memstats();
 
-void
-test_read_only()
-{
-  printf(1, "  TEST 3: Read-Only (No COW Trigger)\n");
-  printf(1, "====================================\n\n");
-  
-  char *buffer = malloc(4096);
-  if(buffer == 0) {
-    printf(1, "ERROR: malloc failed\n");
-    exit();
-  }
-  
-  int i;
-  for(i = 0; i < 4096; i++)
-    buffer[i] = 'R';
-  
   int pid = fork();
-  
-  if(pid < 0) {
-    printf(1, "ERROR: fork failed\n");
-    free(buffer);
-    exit();
-  }
-  
-  if(pid == 0) {
-    printf(1, "[CHILD] Before reading:\n");
-    memstats();
-    
-    int sum = 0;
-    for(i = 0; i < 4096; i++)
-      sum += buffer[i];
-    
-    printf(1, "\n[CHILD] After reading (sum=%d):\n", sum);
-    printf(1, "Expected: Shared pages should NOT decrease\n\n");
-    memstats();
-    
-    free(buffer);
-    exit();
-  } else {
-    wait();
-    free(buffer);
-  }
-}
 
-void
-test_fork_exec()
-{
-  printf(1, "  TEST 4: Fork then Exec (COW Benefit)\n");
-  printf(1, "====================================\n\n");
-  
-  char *buf = malloc(16384);
-  if(buf == 0) {
-    printf(1, "ERROR: malloc failed\n");
-    exit();
-  }
-  
-  int i;
-  for(i = 0; i < 16384; i++)
-    buf[i] = 'B';
-  
-  printf(1, "[PARENT] Before fork (large allocation):\n");
-  memstats();
-  
-  int pid = fork();
-  
   if(pid < 0) {
-    printf(1, "ERROR: fork failed\n");
-    free(buf);
+    printf(1, "fork failed\n");
     exit();
   }
-  
+
   if(pid == 0) {
-    printf(1, "\n[CHILD] After fork:\n");
-    printf(1, "All pages shared! Exec will discard without copying.\n\n");
+    // Child process
+    printf(1, "\nStep 2: Child immediately after fork\n");
+    printf(1, "--------------------------------------\n");
+    printf(1, "NOTE: With COW, pages are SHARED and read-only\n");
+    printf(1, "No physical copying has occurred yet\n\n");
     memstats();
-    
-    printf(1, "\n[CHILD] Calling exec (replaces memory)...\n");
-    char *args[] = { "echo", "COW", "avoided", "copying!", 0 };
-    exec("echo", args);
-    
-    printf(1, "ERROR: exec failed\n");
-    exit();
-  } else {
-    wait();
-    free(buf);
-    
-    printf(1, "\n[PARENT] After child exec:\n");
-    memstats();
-    printf(1, "\nBenefit: Child never copied those 4 pages!\n");
-  }
-}
 
-void
-test_nested_fork()
-{
-  printf(1, "  TEST 5: Nested Fork (Grandchild)\n");
-  printf(1, "======================================\n\n");
-  
-  char *data = malloc(8192);
-  if(data == 0) {
-    printf(1, "ERROR: malloc failed\n");
-    exit();
-  }
-  
-  int i;
-  for(i = 0; i < 8192; i++)
-    data[i] = 'P';
-  
-  printf(1, "[PARENT] Before first fork:\n");
-  memstats();
-  
-  int pid1 = fork();
-  
-  if(pid1 < 0) {
-    printf(1, "ERROR: fork failed\n");
-    free(data);
-    exit();
-  }
-  
-  if(pid1 == 0) {
-    printf(1, "\n[CHILD] After fork from parent:\n");
-    memstats();
-    
-    int pid2 = fork();
-    
-    if(pid2 == 0) {
-      printf(1, "\n[GRANDCHILD] After fork from child:\n");
-      memstats();
-      
-      printf(1, "\n[GRANDCHILD] Writing to data...\n");
-      data[0] = 'G';
-      
-      printf(1, "\n[GRANDCHILD] After write:\n");
-      memstats();
-      
-      free(data);
-      exit();
-    } else {
-      wait();
-      printf(1, "\n[CHILD] After grandchild exits:\n");
-      memstats();
-      free(data);
-      exit();
-    }
-  } else {
-    wait();
-    printf(1, "\n[PARENT] After child exits:\n");
-    memstats();
-    free(data);
-  }
-}
+    printf(1, "\nStep 3: Child writing to private memory (COW trigger)\n");
+    printf(1, "------------------------------------------------------\n");
 
-void
-test_multiple_children()
-{
-  printf(1, "  TEST 6: Multiple Children Sharing Pages\n");
-  printf(1, "========================================\n\n");
-  
-  char *shared = malloc(4096);
-  if(shared == 0) {
-    printf(1, "ERROR: malloc failed\n");
-    exit();
-  }
-  
-  int i;
-  for(i = 0; i < 4096; i++)
-    shared[i] = 'S';
-  
-  printf(1, "[PARENT] Before forking children:\n");
-  memstats();
-  
-  int pids[3];
-  for(i = 0; i < 3; i++) {
-    pids[i] = fork();
-    
-    if(pids[i] < 0) {
-      printf(1, "ERROR: fork %d failed\n", i);
+    char *buf = malloc(8192);
+    if(buf == 0) {
+      printf(1, "malloc failed\n");
       exit();
     }
-    
-    if(pids[i] == 0) {
-      printf(1, "\n[CHILD %d] After fork:\n", i);
-      memstats();
-      
-      printf(1, "\n[CHILD %d] Writing to shared data...\n", i);
-      shared[i * 1000] = 'C';
-      
-      printf(1, "\n[CHILD %d] After write:\n", i);
-      memstats();
-      
-      free(shared);
-      exit();
+
+    for(int i = 0; i < 8192; i++) {
+      buf[i] = 'C';   // should trigger COW page fault(s)
     }
-  }
-  
-  for(i = 0; i < 3; i++)
-    wait();
-  
-  printf(1, "\n[PARENT] After all children exit:\n");
-  memstats();
-  free(shared);
-}
 
-void
-test_large_allocation()
-{
-  printf(1, "  TEST 7: Large Memory Allocation\n");
-  printf(1, "=====================================\n\n");
-  
-  char *large = malloc(32768);
-  if(large == 0) {
-    printf(1, "ERROR: malloc failed\n");
-    exit();
-  }
-  
-  int i;
-  for(i = 0; i < 32768; i++)
-    large[i] = 'L';
-  
-  printf(1, "[PARENT] Allocated 32KB:\n");
-  memstats();
-  
-  int pid = fork();
-  
-  if(pid < 0) {
-    printf(1, "ERROR: fork failed\n");
-    free(large);
-    exit();
-  }
-  
-  if(pid == 0) {
-    printf(1, "\n[CHILD] All 8 pages shared:\n");
-    memstats();
-    
-    printf(1, "\n[CHILD] Writing to every other page...\n");
-    for(i = 0; i < 4; i++)
-      large[i * 8192] = 'C';
-    
-    printf(1, "\n[CHILD] After writing to 4 pages:\n");
+    printf(1, "\nStep 4: Child after write (pages diverged)\n");
+    printf(1, "-------------------------------------------\n");
+    printf(1, "NOTE: Only modified pages are now copied\n\n");
     memstats();
-    printf(1, "Expected: ~4 shared, ~4 private\n");
-    
-    free(large);
-    exit();
-  } else {
-    wait();
-    free(large);
-  }
-}
 
-void
-test_parent_writes_after_fork()
-{
-  printf(1, "  TEST 8: Parent Writes After Fork\n");
-  printf(1, "=====================================\n\n");
-  
-  char *data = malloc(8192);
-  if(data == 0) {
-    printf(1, "ERROR: malloc failed\n");
-    exit();
-  }
-  
-  int i;
-  for(i = 0; i < 8192; i++)
-    data[i] = 'P';
-  
-  int pid = fork();
-  
-  if(pid < 0) {
-    printf(1, "ERROR: fork failed\n");
-    free(data);
-    exit();
-  }
-  
-  if(pid == 0) {
-    printf(1, "[CHILD] After fork (waiting):\n");
-    memstats();
-    
-    sleep(2);
-    
-    printf(1, "\n[CHILD] After parent modified data:\n");
-    memstats();
-    printf(1, "Expected: Pages still shared (child didn't write)\n");
-    
-    free(data);
+    free(buf);
     exit();
+
   } else {
-    printf(1, "\n[PARENT] After fork:\n");
-    memstats();
-    
-    printf(1, "\n[PARENT] Writing to data...\n");
-    data[0] = 'X';
-    data[4096] = 'Y';
-    
-    printf(1, "\n[PARENT] After writes:\n");
-    memstats();
-    printf(1, "Expected: Parent made copies, child unaffected\n");
-    
+    // Parent process
     wait();
-    free(data);
-  }
-}
 
-void
-test_sequential_writes()
-{
-  printf(1, "  TEST 9: Sequential Page Writes\n");
-  printf(1, "====================================\n\n");
-  
-  char *pages = malloc(20480);
-  if(pages == 0) {
-    printf(1, "ERROR: malloc failed\n");
-    exit();
-  }
-  
-  int i;
-  for(i = 0; i < 20480; i++)
-    pages[i] = 'S';
-  
-  int pid = fork();
-  
-  if(pid < 0) {
-    printf(1, "ERROR: fork failed\n");
-    free(pages);
-    exit();
-  }
-  
-  if(pid == 0) {
-    printf(1, "[CHILD] Initial state (5 pages shared):\n");
+    printf(1, "\nStep 5: Parent after child exits\n");
+    printf(1, "----------------------------------\n");
+    printf(1, "NOTE: Parent memory remained unchanged\n\n");
     memstats();
-    
-    for(i = 0; i < 5; i++) {
-      printf(1, "\n[CHILD] Writing to page %d...\n", i);
-      pages[i * 4096] = 'C';
-      
-      printf(1, "[CHILD] After page %d write:\n", i);
-      memstats();
-    }
-    
-    free(pages);
-    exit();
-  } else {
-    wait();
-    free(pages);
-  }
-}
 
-void
-test_stress_cow()
-{
-  printf(1, "  TEST 10: COW Stress Test\n");
-  printf(1, "===============================\n\n");
-  
-  printf(1, "[STRESS] Forking 5 children with 16KB each...\n");
-  
-  int i, j;
-  for(i = 0; i < 5; i++) {
-    char *mem = malloc(16384);
-    if(mem == 0) {
-      printf(1, "ERROR: malloc failed\n");
-      exit();
-    }
-    
-    for(j = 0; j < 16384; j++)
-      mem[j] = 'M';
-    
-    int pid = fork();
-    
-    if(pid < 0) {
-      printf(1, "ERROR: fork failed\n");
-      free(mem);
-      exit();
-    }
-    
-    if(pid == 0) {
-      printf(1, "[CHILD %d] Forked:\n", i);
-      memstats();
-      
-      mem[i * 1000] = 'C';
-      
-      printf(1, "[CHILD %d] After write:\n", i);
-      memstats();
-      
-      free(mem);
-      exit();
-    }
-    
-    free(mem);
+    printf(1, "\n=== Task 2 Complete ===\n");
+    printf(1, "Observation:\n");
+    printf(1, "- Pages were shared after fork\n");
+    printf(1, "- Physical copies created ONLY on write\n");
+    printf(1, "- Confirms correct Copy-On-Write behavior\n\n");
   }
-  
-  for(i = 0; i < 5; i++)
-    wait();
-  
-  printf(1, "\n[STRESS] All children completed successfully!\n");
-}
 
-int
-main(int argc, char *argv[])
-{
-  printf(1, "\n");
-  printf(1, "================================================\n");
-  printf(1, "   XV6 Copy-On-Write Comprehensive Test Suite  \n");
-  printf(1, "              Task 2 - Extended                 \n");
-  printf(1, "================================================\n");
-  
-  test_simple_cow();
-  test_multiple_pages();
-  test_read_only();
-  test_fork_exec();
-  test_nested_fork();
-  test_multiple_children();
-  test_large_allocation();
-  test_parent_writes_after_fork();
-  test_sequential_writes();
-  test_stress_cow();
-  
-  printf(1, "\n\n");
-  printf(1, "   ALL 10 COW TESTS COMPLETED SUCCESSFULLY!    \n");
-  printf(1, "================================================\n\n");
-  
   exit();
 }
\ No newline at end of file
diff --git a/compare_repo/defs.h b/compare_repo/defs.h
index 82fb982..708daff 100644
--- a/compare_repo/defs.h
+++ b/compare_repo/defs.h
@@ -68,7 +68,8 @@ char*           kalloc(void);
 void            kfree(char*);
 void            kinit1(void*, void*);
 void            kinit2(void*, void*);
-
+void            krefpage(void*);
+int             kgetrefcount(void*);
 // kbd.c
 void            kbdintr(void);
 
@@ -120,6 +121,7 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+int            demo(void); //demo added
 
 // swtch.S
 void            swtch(struct context**, struct context*);
@@ -185,6 +187,9 @@ void            switchuvm(struct proc*);
 void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
+int             countpages(pde_t*, int, int); // for the function call of "countpages" & "getmemstats"
+void            getmemstats(struct proc*, int*, int*, int*);
+int             cowhandler(pde_t*, uint);
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/compare_repo/kalloc.c b/compare_repo/kalloc.c
index 14cd4f4..8f3ea32 100644
--- a/compare_repo/kalloc.c
+++ b/compare_repo/kalloc.c
@@ -32,7 +32,6 @@ void
 kinit1(void *vstart, void *vend)
 {
   initlock(&kmem.lock, "kmem");
-  kmem.use_lock = 0;
   freerange(vstart, vend);
 }
 
@@ -51,6 +50,7 @@ freerange(void *vstart, void *vend)
   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
     kfree(p);
 }
+
 //PAGEBREAK: 21
 // Free the page of physical memory pointed at by v,
 // which normally should have been returned by a
@@ -91,6 +91,6 @@ kalloc(void)
     kmem.freelist = r->next;
   if(kmem.use_lock)
     release(&kmem.lock);
-  return (char*)r;
-}
 
+  return (char*)r;
+}
\ No newline at end of file
diff --git a/compare_repo/mmu.h b/compare_repo/mmu.h
index a82d8e2..47a5626 100644
--- a/compare_repo/mmu.h
+++ b/compare_repo/mmu.h
@@ -95,6 +95,7 @@ struct segdesc {
 #define PTE_W           0x002   // Writeable
 #define PTE_U           0x004   // User
 #define PTE_PS          0x080   // Page Size
+#define PTE_COW         0x800   // Copy-On-Write flag (bit 
 
 // Address in page table or page directory entry
 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
diff --git a/compare_repo/proc.c b/compare_repo/proc.c
index 806b1b1..963edc4 100644
--- a/compare_repo/proc.c
+++ b/compare_repo/proc.c
@@ -211,6 +211,9 @@ fork(void)
   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
 
   pid = np->pid;
+  // Track parent info for CMDT
+  np->parent_pid = curproc->pid;
+  np->fork_time = ticks;
 
   acquire(&ptable.lock);
 
@@ -532,3 +535,10 @@ procdump(void)
     cprintf("\n");
   }
 }
+//printing the system call
+int 
+demo(void)
+{
+  cprintf("Demo");
+  return 22;
+}
\ No newline at end of file
diff --git a/compare_repo/proc.h b/compare_repo/proc.h
index 1647114..d775f46 100644
--- a/compare_repo/proc.h
+++ b/compare_repo/proc.h
@@ -49,6 +49,11 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int parent_pid;              //L-52-56 to implement CMDT
+  uint fork_time;
+  int shared_pages;
+  int private_pages;
+  int modified_pages;
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/compare_repo/syscall.c b/compare_repo/syscall.c
index ee85261..736f876 100644
--- a/compare_repo/syscall.c
+++ b/compare_repo/syscall.c
@@ -103,6 +103,8 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_demo(void);
+extern int sys_memstats(void); //extern declaration for memstats
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +128,8 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_demo]   sys_demo, //demo
+[SYS_memstats] sys_memstats, //memstats
 };
 
 void
@@ -143,3 +147,28 @@ syscall(void)
     curproc->tf->eax = -1;
   }
 }
+//Impplemeting this function for "System Call Implementtion" L:1480-172
+int
+sys_memstats(void)
+{
+  struct proc *p = myproc();
+  int shared, private_pg, modified;
+  
+  // Get memory statistics
+  getmemstats(p, &shared, &private_pg, &modified);
+  
+  // Print formatted output
+  cprintf("Child Memory Divergence Tracker (CMDT)\n");
+  cprintf("Process: %s (PID: %d)\n", p->name, p->pid);
+  
+  if(p->parent_pid > 0)
+    cprintf("Parent PID: %d\n", p->parent_pid);
+    
+  cprintf("Shared pages:   %d\n", shared);
+  cprintf("Private pages:  %d\n", private_pg);
+  cprintf("Modified pages: %d\n", modified);
+  cprintf("Total pages:    %d\n", shared + private_pg);
+  cprintf("\n");
+  
+  return 0;
+}
\ No newline at end of file
diff --git a/compare_repo/syscall.h b/compare_repo/syscall.h
index bc5f356..bea8254 100644
--- a/compare_repo/syscall.h
+++ b/compare_repo/syscall.h
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_demo   22 //added demo
+#define SYS_memstats 23 //added memstats
\ No newline at end of file
diff --git a/compare_repo/sysproc.c b/compare_repo/sysproc.c
index 0686d29..8fe2fed 100644
--- a/compare_repo/sysproc.c
+++ b/compare_repo/sysproc.c
@@ -89,3 +89,9 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+// return value of demo
+int 
+sys_demo(void)
+{
+  return 22;
+}
\ No newline at end of file
diff --git a/compare_repo/trap.c b/compare_repo/trap.c
index 41c66eb..ee15a73 100644
--- a/compare_repo/trap.c
+++ b/compare_repo/trap.c
@@ -31,7 +31,6 @@ idtinit(void)
 {
   lidt(idt, sizeof(idt));
 }
-
 //PAGEBREAK: 41
 void
 trap(struct trapframe *tf)
@@ -61,7 +60,6 @@ trap(struct trapframe *tf)
     lapiceoi();
     break;
   case T_IRQ0 + IRQ_IDE+1:
-    // Bochs generates spurious IDE1 interrupts.
     break;
   case T_IRQ0 + IRQ_KBD:
     kbdintr();
@@ -78,35 +76,36 @@ trap(struct trapframe *tf)
     lapiceoi();
     break;
 
-  //PAGEBREAK: 13
   default:
     if(myproc() == 0 || (tf->cs&3) == 0){
-      // In kernel, it must be our mistake.
       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
               tf->trapno, cpuid(), tf->eip, rcr2());
       panic("trap");
     }
-    // In user space, assume process misbehaved.
+    
+    // Handle COW page faults
+    if(tf->trapno == T_PGFLT) {
+      uint va = rcr2();
+      if(cowhandler(myproc()->pgdir, va) == 0) {
+        break;
+      }
+    }
+    
     cprintf("pid %d %s: trap %d err %d on cpu %d "
             "eip 0x%x addr 0x%x--kill proc\n",
             myproc()->pid, myproc()->name, tf->trapno,
             tf->err, cpuid(), tf->eip, rcr2());
     myproc()->killed = 1;
+    break;
   }
 
-  // Force process exit if it has been killed and is in user space.
-  // (If it is still executing in the kernel, let it keep running
-  // until it gets to the regular system call return.)
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
     exit();
 
-  // Force process to give up CPU on clock tick.
-  // If interrupts were on while locks held, would need to check nlock.
   if(myproc() && myproc()->state == RUNNING &&
      tf->trapno == T_IRQ0+IRQ_TIMER)
     yield();
 
-  // Check if the process has been killed since we yielded
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
     exit();
-}
+}
\ No newline at end of file
diff --git a/compare_repo/user.h b/compare_repo/user.h
index 4f99c52..aa9eb49 100644
--- a/compare_repo/user.h
+++ b/compare_repo/user.h
@@ -23,6 +23,8 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int demo(void); //demo added
+int memstats(void); //memstats added
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/compare_repo/vm.c b/compare_repo/vm.c
index 7134cff..76b6e09 100644
--- a/compare_repo/vm.c
+++ b/compare_repo/vm.c
@@ -271,8 +271,15 @@ deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
       if(pa == 0)
         panic("kfree");
       char *v = P2V(pa);
-      kfree(v);
-      *pte = 0;
+      
+      // If it's a COW page, just remove the mapping
+      // Don't free the physical page (might be shared)
+      if(*pte & PTE_COW) {
+        *pte = 0;
+      } else {
+        kfree(v);
+        *pte = 0;
+      }
     }
   }
   return newsz;
@@ -310,6 +317,10 @@ clearpteu(pde_t *pgdir, char *uva)
   *pte &= ~PTE_U;
 }
 
+// Given a parent process's page table, create a copy
+// of it for a child.
+// Given a parent process's page table, create a copy
+// of it for a child.
 // Given a parent process's page table, create a copy
 // of it for a child.
 pde_t*
@@ -318,7 +329,6 @@ copyuvm(pde_t *pgdir, uint sz)
   pde_t *d;
   pte_t *pte;
   uint pa, i, flags;
-  char *mem;
 
   if((d = setupkvm()) == 0)
     return 0;
@@ -329,19 +339,23 @@ copyuvm(pde_t *pgdir, uint sz)
       panic("copyuvm: page not present");
     pa = PTE_ADDR(*pte);
     flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
-      goto bad;
-    memmove(mem, (char*)P2V(pa), PGSIZE);
-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
-      kfree(mem);
-      goto bad;
+    
+    // COW optimization: share pages, mark read-only
+    if(flags & PTE_W) {
+      // Mark as COW in both parent and child
+      flags = (flags & ~PTE_W) | PTE_COW;
+      *pte = pa | flags;
+    }
+    
+    if(mappages(d, (void*)i, PGSIZE, pa, flags) < 0) {
+      freevm(d);
+      return 0;
     }
   }
+  
+  lcr3(V2P(pgdir)); // Flush TLB
   return d;
 
-bad:
-  freevm(d);
-  return 0;
 }
 
 //PAGEBREAK!
@@ -359,6 +373,9 @@ uva2ka(pde_t *pgdir, char *uva)
   return (char*)P2V(PTE_ADDR(*pte));
 }
 
+// Copy len bytes from p to user address va in page table pgdir.
+// Most useful when pgdir is not the current page table.
+// uva2ka ensures this only works for PTE_U pages.
 // Copy len bytes from p to user address va in page table pgdir.
 // Most useful when pgdir is not the current page table.
 // uva2ka ensures this only works for PTE_U pages.
@@ -367,10 +384,19 @@ copyout(pde_t *pgdir, uint va, void *p, uint len)
 {
   char *buf, *pa0;
   uint n, va0;
+  pte_t *pte;
 
   buf = (char*)p;
   while(len > 0){
     va0 = (uint)PGROUNDDOWN(va);
+    
+    // Check for COW page before writing
+    pte = walkpgdir(pgdir, (void*)va0, 0);
+    if(pte && (*pte & PTE_COW)) {
+      if(cowhandler(pgdir, va0) < 0)
+        return -1;
+    }
+    
     pa0 = uva2ka(pgdir, (char*)va0);
     if(pa0 == 0)
       return -1;
@@ -385,6 +411,67 @@ copyout(pde_t *pgdir, uint va, void *p, uint len)
   return 0;
 }
 
+// Count pages in a page directory with specific characteristics L:387-428
+// Count pages in a page directory with specific characteristics
+// Count pages in a page directory with specific characteristics
+int
+countpages(pde_t *pgdir, int check_cow, int check_writable)
+{
+  int count = 0;
+  pte_t *pte;
+  uint i;
+  pde_t *pde;
+  
+  // Walk through valid page directory entries
+  for(i = 0; i < NPDENTRIES && i < (KERNBASE >> PDXSHIFT); i++) {
+    pde = &pgdir[i];
+    
+    if(!(*pde & PTE_P))
+      continue;
+      
+    pte_t *pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+    
+    // Walk through page table entries
+    int j;
+    for(j = 0; j < NPTENTRIES; j++) {
+      pte = &pgtab[j];
+      
+      if((*pte & PTE_P) && (*pte & PTE_U)) {
+        if(check_cow && (*pte & PTE_COW))
+          count++;
+        else if(check_writable && (*pte & PTE_W) && !(*pte & PTE_COW))
+          count++;
+        else if(!check_cow && !check_writable)
+          count++;
+      }
+    }
+  }
+  
+  return count;
+}
+
+// Get memory statistics for a process
+// Get memory statistics for a process
+void
+getmemstats(struct proc *p, int *shared, int *private_pg, int *modified)
+{
+  *shared = 0;
+  *private_pg = 0;
+  *modified = 0;
+  
+  if(p->pgdir == 0)
+    return;
+    
+  // Count COW pages as shared
+  *shared = countpages(p->pgdir, 1, 0);
+  
+  // Count writable non-COW pages as private
+  *private_pg = countpages(p->pgdir, 0, 1);
+  
+  // Modified pages = private pages
+  *modified = *private_pg;
+}
+
 //PAGEBREAK!
 // Blank page.
 //PAGEBREAK!
@@ -392,3 +479,47 @@ copyout(pde_t *pgdir, uint va, void *p, uint len)
 //PAGEBREAK!
 // Blank page.
 
+// Handle Copy-On-Write page fault
+// Handle Copy-On-Write page fault
+// Handle Copy-On-Write page fault
+int
+cowhandler(pde_t *pgdir, uint va)
+{
+  pte_t *pte;
+  uint pa;
+  uint flags;
+  char *mem;
+  
+  if(va >= KERNBASE)
+    return -1;
+    
+  pte = walkpgdir(pgdir, (void*)va, 0);
+  if(pte == 0)
+    return -1;
+  if(!(*pte & PTE_P))
+    return -1;
+  if(!(*pte & PTE_U))
+    return -1;
+    
+  // Check if this is a COW page
+  if(!(*pte & PTE_COW))
+    return -1;
+    
+  // Get physical address and allocate new page
+  pa = PTE_ADDR(*pte);
+  mem = kalloc();
+  if(mem == 0)
+    return -1;
+    
+  // Copy old page to new page
+  memmove(mem, (char*)P2V(pa), PGSIZE);
+  
+  // Update PTE: make it writable, remove COW flag
+  flags = PTE_FLAGS(*pte);
+  flags = (flags & ~PTE_COW) | PTE_W;
+  *pte = V2P(mem) | flags;
+  
+  lcr3(V2P(pgdir)); // Flush TLB
+  
+  return 0;
+}
\ No newline at end of file
